var documenterSearchIndex = {"docs":
[{"location":"api/#Neurthino.jl-1","page":"API","title":"Neurthino.jl","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"A Julia package to get access for neutrino oscillations.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Modules = [Neurthino]","category":"page"},{"location":"api/#Neurthino.MatterOscillationMatrices-NTuple{4, Any}","page":"API","title":"Neurthino.MatterOscillationMatrices","text":"MatterOscillationMatrices(U, H, energy, density; zoa, anti)\n\n\nCreate modified oscillation parameters for neutrino propagation through matter\n\nArguments\n\nP: Vacuum PMNS Matrix\nH: Vacuum Hamiltonian\ndensity: Matter density [g*cm^-3] \nenergy: Neutrino energy [GeV]\nzoa: Proton nucleon ratio (Z/A)\nanti: Is anti neutrino\n\n\n\n\n\n","category":"method"},{"location":"api/#Neurthino.MatterOscillationMatrices-Tuple{Any, Any, Any}","page":"API","title":"Neurthino.MatterOscillationMatrices","text":"MatterOscillationMatrices(H_eff, energy, density; zoa, anti)\n\n\nCreate modified oscillation parameters for neutrino propagation through matter\n\nArguments\n\nH_eff: Effective Matter Hamiltonian\ndensity: Matter density [g*cm^-3] \nenergy: Neutrino energy [GeV]\nzoa: Proton nucleon ratio (Z/A)\nanti: Is anti neutrino\n\n\n\n\n\n","category":"method"},{"location":"api/#Neurthino.MatterOscillationMatrices-Tuple{OscillationParameters, Any, Any}","page":"API","title":"Neurthino.MatterOscillationMatrices","text":"MatterOscillationMatrices(osc_vacuum, energy, density; zoa, anti)\n\n\nCreate modified oscillation parameters for neutrino propagation through matter\n\nArguments\n\nosc_vacuum::OscillationParameters: Oscillation parameters in vacuum\nenergy: Neutrino energy [GeV]\ndensity: Matter density in g*cm^-3 \nzoa: Proton nucleon ratio (Z/A)\nanti: Is anti neutrino\n\n\n\n\n\n","category":"method"},{"location":"api/#Neurthino.cpphase!-Union{Tuple{S}, Tuple{T}, Tuple{OscillationParameters, Pair{T, T}, S}} where {T<:Integer, S<:Real}","page":"API","title":"Neurthino.cpphase!","text":"Set a CP phase of an oscillation parameters struct\n\nArguments\n\nosc::OscillationParameters: Oscillation parameters \nindices::Pair{<:Integer, <:Integer}: The indices of the mass difference\nvalue The value which should be applied to the oscillation parameters\n\n\n\n\n\n","category":"method"},{"location":"api/#Neurthino.cpphase!-Union{Tuple{S}, Tuple{T}, Tuple{OscillationParameters, Vararg{Tuple{Pair{T, T}, S}, N} where N}} where {T<:Integer, S<:Real}","page":"API","title":"Neurthino.cpphase!","text":"Set a CP phase of an oscillation parameters struct\n\nArguments\n\nosc::OscillationParameters: Oscillation parameters \nargs::Tuple{Pair{<:Integer, <:Integer}, <:Number}: Indices and values of the CP phase\n\n\n\n\n\n","category":"method"},{"location":"api/#Neurthino.cpphases-Tuple{Any}","page":"API","title":"Neurthino.cpphases","text":"cpphases(n)\n\n\nReturns the number of CP violating phases at given number of neutrino types\n\nArguments\n\nn: number of neutrino types in the supposed model\n\nExamples\n\njulia> cpphases(3)\n1\n\n\n\n\n\n","category":"method"},{"location":"api/#Neurthino.masssquareddiff!-Tuple{OscillationParameters, Vararg{Tuple{Pair{var\"#s37\", var\"#s38\"} where {var\"#s37\"<:Integer, var\"#s38\"<:Integer}, Number}, N} where N}","page":"API","title":"Neurthino.masssquareddiff!","text":"masssquareddiff!(osc, args)\n\n\nSet a mass squared difference of an oscillation parameters struct\n\nArguments\n\nosc::OscillationParameters: Oscillation parameters \nargs::Tuple{Pair{<:Integer, <:Integer}, <:Number}: Indices and values of the mass squared difference\n\n\n\n\n\n","category":"method"},{"location":"api/#Neurthino.masssquareddiff!-Union{Tuple{S}, Tuple{T}, Tuple{OscillationParameters, Pair{T, T}, S}} where {T<:Integer, S<:Number}","page":"API","title":"Neurthino.masssquareddiff!","text":"masssquareddiff!(osc, indices, value)\n\n\nSet a mass squared difference of an oscillation parameters struct\n\nArguments\n\nosc::OscillationParameters: Oscillation parameters \nindices::Pair{<:Integer, <:Integer}: The indices of the mass squared difference\nvalue The value which should be applied to the oscillation parameters\n\n\n\n\n\n","category":"method"},{"location":"api/#Neurthino.mixingangle!-Union{Tuple{S}, Tuple{T}, Tuple{OscillationParameters, Pair{T, T}, S}} where {T<:Integer, S<:Real}","page":"API","title":"Neurthino.mixingangle!","text":"mixingangle!(osc, indices, value)\n\n\nSet a mixing angle of an oscillation parameters struct\n\nArguments\n\nosc::OscillationParameters: Oscillation parameters \nindices::Pair{<:Integer, <:Integer}: The indices of the mixing angle\nvalue<:Real The value which should be applied to the oscillation parameters\n\n\n\n\n\n","category":"method"},{"location":"api/#Neurthino.mixingangle!-Union{Tuple{S}, Tuple{T}, Tuple{OscillationParameters, Vararg{Tuple{Pair{T, T}, S}, N} where N}} where {T<:Integer, S<:Real}","page":"API","title":"Neurthino.mixingangle!","text":"mixingangle!(osc, args)\n\n\nSet a mixing angle of an oscillation parameters struct\n\nArguments\n\nosc::OscillationParameters: Oscillation parameters \nargs::Tuple{Pair{<:Integer, <:Integer}, <:Real}: The indices of the mixing angle\n\n\n\n\n\n","category":"method"},{"location":"api/#Neurthino.mixingangles-Tuple{Any}","page":"API","title":"Neurthino.mixingangles","text":"mixingangles(n)\n\n\nReturns the number of mixing angles at given number of neutrino types\n\nArguments\n\nn: number of neutrino types in the supposed model\n\nExamples\n\njulia> mixingangles(3)\n3\n\n\n\n\n\n","category":"method"},{"location":"api/#Neurthino.oscprob-Tuple{OscillationParameters, Any, Any}","page":"API","title":"Neurthino.oscprob","text":"oscprob(osc_params, energy, baseline; anti)\n\n\nCalculate the transistion probabilities between the neutrino flavours\n\nArguments\n\nosc_params::OscillationParameters:  Oscillation parameters\nenergy:                             Energy [GeV]\nbaseline:                           Baseline [km]\nanti:                               Is anti neutrino\n\n\n\n\n\n","category":"method"},{"location":"api/#Neurthino.oscprob-Tuple{OscillationParameters, Any, Union{Neurthino.Path, Vector{Neurthino.Path}}}","page":"API","title":"Neurthino.oscprob","text":"oscprob(osc_vacuum, energy, path; zoa, anti)\n\n\nArguments\n\nosc_vacuum::OscillationParameters: Vacuum oscillation parameters\nenergy: Neutrino energy [GeV]\npath: Neutrino path\nzoa: Proton nucleon ratio (Z/A)\nanti: Is anti neutrino\n\n\n\n\n\n","category":"method"},{"location":"api/#Neurthino.oscprob-Union{Tuple{S}, Tuple{T}, Tuple{Any, Any, Vector{T}, Vector{S}}} where {T, S<:Real}","page":"API","title":"Neurthino.oscprob","text":"oscprob(U, H, energy, baseline)\n\n\nCalculate the transistion probabilities between the neutrino flavours\n\nArguments\n\nU:          PMNS Matrix\nH:          Hamiltonian\nenergy:     Energies [GeV]\nbaseline:   Baselines [km]\n\n\n\n\n\n","category":"method"},{"location":"api/#Neurthino.oscprob-Union{Tuple{T}, Tuple{Any, Any, Vector{T}, Vector{Neurthino.Path}}} where T<:Real","page":"API","title":"Neurthino.oscprob","text":"oscprob(U, H, energy, path; zoa, anti)\n\n\nArguments\n\nU: Vacuum PMNS Matrix\nH: Vacuum Hamiltonian\nenergy: Neutrino energy [GeV]\npath::Vector{Path}: Neutrino path\nzoa: Proton nucleon ratio (Z/A)\nanti: Is anti neutrino\n\n\n\n\n\n","category":"method"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Codecov) (Image: DOI)","category":"page"},{"location":"#Neurthino.jl-1","page":"Introduction","title":"Neurthino.jl","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Neurthino.jl is a package for calculating neutrino oscillation probabilities. The main focus of the package lies on atmospheric neutrino flux and the neutrino propagation through earth.","category":"page"},{"location":"#Basic-Usage-1","page":"Introduction","title":"Basic Usage","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"First of all the basic vacuum properties have to be defined by creating a OscillationParameters struct with fixed number of neutrino flavours of the  considered model:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> using Neurthino\n\njulia> osc = OscillationParameters(3);","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The values of the mixing angles (setθ!), mass squared differences (setΔm²) and CP phases (setδ!) are initialised to 0 and have to be set individually:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> setθ!(osc, 1=>2, 0.59);\n\njulia> setθ!(osc, 1=>3, 0.15);\n\njulia> setθ!(osc, 2=>3, 0.84);\n\njulia> setδ!(osc, 1=>3, 3.86);","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The mass squared differences are defined as <img src=\"https://render.githubusercontent.com/render/math?math=\\Delta{ij}=mi^2-mj^2\"> and within the package the convention <img src=\"https://render.githubusercontent.com/render/math?math=\\forall%20i%3Cj:mi%3Cm_j\"> is kept.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> setΔm²!(osc, 2=>3, -2.523e-3);\n\njulia> setΔm²!(osc, 1=>2, -7.39e-5);","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"These oscillation parameters can now be used to calculate the oscillation probabilities between the flavour states: ","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> p = Pνν(osc, 1, 10000)\n4-dimensional AxisArray{Float64,4,...} with axes:\n    :Energy, [1.0]\n    :Baseline, [10000.0]\n    :InitFlav, NeutrinoFlavour[Electron, Muon, Tau]\n    :FinalFlav, NeutrinoFlavour[Electron, Muon, Tau]\nAnd data, a 1×1×3×3 Array{Float64,4}:\n[:, :, 1, 1] =\n 0.40280077905806266\n\n[:, :, 2, 1] =\n 0.24823028034134093\n\n[:, :, 3, 1] =\n 0.348968940600596\n\n[:, :, 1, 2] =\n 0.10025499082597984\n\n[:, :, 2, 2] =\n 0.49250415138072934\n\n[:, :, 3, 2] =\n 0.4072408577932906\n\n[:, :, 1, 3] =\n 0.49694423011595723\n\n[:, :, 2, 3] =\n 0.2592655682779296\n\n[:, :, 3, 3] =\n 0.24379020160611306","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The output is an AxisArray which provides intuitive indexing, e.g. for P(νμ→ντ) at the given energy and baseline:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> p[Energy=1, Baseline=1, InitFlav=Muon, FinalFlav=Tau]\n0.2592655682779296","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The probabilities are calculated based on the transition matrix  (the so-called PMNS-Matrix) between flavour and mass eigenstates, as well as the Hamiltonian in the mass eigenbasis. In order to calculating these  just once, the Pνν function can be utilised in the following way:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> U = PMNSMatrix(osc)\n3×3 Array{Complex{Float64},2}:\n   0.82161+0.0im         0.550114+0.0im        -0.112505+0.0983582im\n -0.301737+0.0608595im   0.601232+0.0407488im   0.736282+0.0im\n  0.476688+0.0545516im  -0.576975+0.0365253im   0.659968+0.0im\n\njulia> H = Hamiltonian(osc)\n3-element Array{Complex{Float64},1}:\n -0.0008902666666666667 + 0.0im\n -0.0008163666666666667 + 0.0im\n  0.0017066333333333333 + 0.0im\n\njulia> Pνν(U, H, 1, 10000)\n4-dimensional AxisArray{Float64,4,...} with axes:\n    :Energy, [1.0]\n    :Baseline, [10000.0]\n    :InitFlav, NeutrinoFlavour[Electron, Muon, Tau]\n    :FinalFlav, NeutrinoFlavour[Electron, Muon, Tau]\nAnd data, a 1×1×3×3 Array{Float64,4}:\n[:, :, 1, 1] =\n 0.40280077905806266\n\n[:, :, 2, 1] =\n 0.24823028034134093\n\n[:, :, 3, 1] =\n 0.348968940600596\n\n[:, :, 1, 2] =\n 0.10025499082597984\n\n[:, :, 2, 2] =\n 0.49250415138072934\n\n[:, :, 3, 2] =\n 0.4072408577932906\n\n[:, :, 1, 3] =\n 0.49694423011595723\n\n[:, :, 2, 3] =\n 0.2592655682779296\n\n[:, :, 3, 3] =\n 0.24379020160611306","category":"page"},{"location":"#Oscillations-in-Vacuum-1","page":"Introduction","title":"Oscillations in Vacuum","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"For homogeneous matter with a fixed density, a modified PMNS-Matrix and Hamiltonian can be determined and passed into Pνν, just like for oscillations in vacuum. In order to determine the modified PMNS-Matrix and Hamiltonian the neutrino energy and the matter density are required: ","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> U_mat, H_mat = MatterOscillationMatrices(U, H, 1, 13);\n\njulia> H_mat\n3-element Array{Complex{Float64},1}:\n -0.0008404901318507502 - 2.5459232191294903e-20im\n   9.078126149399635e-5 - 1.75151351027943e-20im\n  0.0017419062876598283 - 1.8741859435908039e-19im\n\njulia> U_mat\n3×3 Array{Complex{Float64},2}:\n  0.0358018-0.000158113im  0.970863+0.0im       -0.178275+0.156083im\n -0.662778+0.00661213im    0.157174+0.116074im   0.722845+0.0im\n  0.74793+0.0im            0.0917808+0.104043im  0.649115-0.00104331im","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The oscillation probabilities using the Pνν function, as described above:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> Pνν(U_mat, H_mat, 1, 10000)\n4-dimensional AxisArray{Float64,4,...} with axes:\n    :Energy, [1]\n    :Baseline, [10000]\n    :InitFlav, NeutrinoFlavour[Electron, Muon, Tau]\n    :FinalFlav, NeutrinoFlavour[Electron, Muon, Tau]\nAnd data, a 1×1×3×3 Array{Float64,4}:\n[:, :, 1, 1] =\n 0.8340722296308641\n\n[:, :, 2, 1] =\n 0.08290502782120308\n\n[:, :, 3, 1] =\n 0.08302274254793415\n\n[:, :, 1, 2] =\n 0.10825570726818898\n\n[:, :, 2, 2] =\n 0.052976635020068\n\n[:, :, 3, 2] =\n 0.8387676577117485\n\n[:, :, 1, 3] =\n 0.05767206310094823\n\n[:, :, 2, 3] =\n 0.8641183371587345\n\n[:, :, 3, 3] =\n 0.07820959974032213\n","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The second option is suitable for scenarios with more complex paths with sections of different densities. An example is shown in the next chapter, where we propagate neutrinos through the earth.","category":"page"},{"location":"#Neutrino-Propagation-through-the-Earth-1","page":"Introduction","title":"Neutrino Propagation through the Earth","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The Neurthino.jl package also includes features for the neutrino oscillation probabilities through the Earth, i.e. it contains functions for generating a neutrino path based on the PREM model. In the following example a neutrino oscillogram with a resolution of 200x200 bins is determined. The zenith angles for up going neutrinos (cos(θ)ϵ[-1,0]) and  subsequently the neutrino paths are generated first:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> zenith = acos.(range(-1,stop=0,length=200));\n\njulia> paths = Neurthino.prempath(zenith, 2.5, samples=100, discrete_densities=0:0.1:14);","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The detector is assumed to be 2.5km under the earth's surface (a typical KM3NeT detector block in the Mediterranean), which is a realistic scenario for Water-Cherenkov-Detectors in sea or ice. Each path consists of 100 sections of equal lengths while the matter density is taken from the PREM model. If a vector of densities is passed as discrete_densities, the values are  clipped to the closest value.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> energies = 10 .^ range(0, stop=2, length=200);\n\njulia> prob = Pνν(U, H, energies, paths);","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The returned array prob is again of type AxisArray with an axis Path for the path index (instead of the Baseline axis). P(νe&#8594;νe) is determined by prob[InitFlav=Electron, FinalFlav=Electron], which can be visualised by a heatmap:<br /> (Image: ) <br /> and for P(νμ&#8594;νμ) or prob[InitFlav=Muon, FinalFlav=Muon]:<br /> (Image: ) <!– @index --> <!-- –> <!–  –> <!– @autodocs --> <!-- Modules = [Neurthino] --> <!-- –>","category":"page"}]
}
